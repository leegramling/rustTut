// Tutorial 10: Procedural Macros - Complete Implementation
// 
// This file contains complete implementations of procedural macros for the space simulation engine.
// Note: In practice, procedural macros would be in a separate proc-macro crate.

use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::collections::hash_map::DefaultHasher;

// ================================
// Exercise 1: Derive Macro for Components
// ================================

pub trait SimulationComponent {
    fn component_type(&self) -> &'static str;
    fn component_id(&self) -> u64;
    fn serialize_data(&self) -> Vec<u8>;
}

// Simulate derive macro output for Transform
pub struct Transform {
    pub position: [f32; 3],
    pub rotation: [f32; 4], // quaternion
    pub scale: [f32; 3],
}

impl SimulationComponent for Transform {
    fn component_type(&self) -> &'static str {
        "Transform"
    }
    
    fn component_id(&self) -> u64 {
        // Generate a compile-time hash of the type name
        let mut hasher = DefaultHasher::new();
        "Transform".hash(&mut hasher);
        hasher.finish()
    }
    
    fn serialize_data(&self) -> Vec<u8> {
        let mut data = Vec::new();
        
        // Serialize position
        for &coord in &self.position {
            data.extend_from_slice(&coord.to_le_bytes());
        }
        
        // Serialize rotation
        for &coord in &self.rotation {
            data.extend_from_slice(&coord.to_le_bytes());
        }
        
        // Serialize scale
        for &coord in &self.scale {
            data.extend_from_slice(&coord.to_le_bytes());
        }
        
        data
    }
}

pub struct RigidBody {
    pub mass: f32,
    pub velocity: [f32; 3],
    pub angular_velocity: [f32; 3],
    pub is_kinematic: bool,
}

impl SimulationComponent for RigidBody {
    fn component_type(&self) -> &'static str {
        "RigidBody"
    }
    
    fn component_id(&self) -> u64 {
        let mut hasher = DefaultHasher::new();
        "RigidBody".hash(&mut hasher);
        hasher.finish()
    }
    
    fn serialize_data(&self) -> Vec<u8> {
        let mut data = Vec::new();
        
        data.extend_from_slice(&self.mass.to_le_bytes());
        
        for &coord in &self.velocity {
            data.extend_from_slice(&coord.to_le_bytes());
        }
        
        for &coord in &self.angular_velocity {
            data.extend_from_slice(&coord.to_le_bytes());
        }
        
        data.push(if self.is_kinematic { 1 } else { 0 });
        
        data
    }
}

pub struct Container<T> {
    pub items: Vec<T>,
    pub capacity: usize,
}

impl<T> SimulationComponent for Container<T>
where
    T: Clone,
{
    fn component_type(&self) -> &'static str {
        "Container"
    }
    
    fn component_id(&self) -> u64 {
        let mut hasher = DefaultHasher::new();
        "Container".hash(&mut hasher);
        std::any::TypeId::of::<T>().hash(&mut hasher);
        hasher.finish()
    }
    
    fn serialize_data(&self) -> Vec<u8> {
        let mut data = Vec::new();
        data.extend_from_slice(&self.items.len().to_le_bytes());
        data.extend_from_slice(&self.capacity.to_le_bytes());
        // Note: Would need T: Serialize for full implementation
        data
    }
}

// ================================
// Exercise 2: Builder Pattern Derive Macro
// ================================

pub trait Builder<T> {
    fn build(self) -> Result<T, BuilderError>;
}

#[derive(Debug)]
pub enum BuilderError {
    MissingField(&'static str),
    ValidationFailed(&'static str),
}

pub struct SpaceShip {
    pub name: String,
    pub mass: f32,
    pub engine_power: f32,
    pub crew_capacity: u32,
    pub fuel_capacity: f32,
}

// Generated by derive macro
pub struct SpaceShipBuilder {
    name: Option<String>,
    mass: Option<f32>,
    engine_power: Option<f32>,
    crew_capacity: Option<u32>,
    fuel_capacity: Option<f32>,
}

impl SpaceShipBuilder {
    pub fn new() -> Self {
        Self {
            name: None,
            mass: None,
            engine_power: None,
            crew_capacity: None,
            fuel_capacity: None,
        }
    }
    
    pub fn name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }
    
    pub fn mass(mut self, mass: f32) -> Self {
        if mass <= 0.0 {
            panic!("Mass must be positive");
        }
        self.mass = Some(mass);
        self
    }
    
    pub fn engine_power(mut self, power: f32) -> Self {
        if power < 0.0 {
            panic!("Engine power cannot be negative");
        }
        self.engine_power = Some(power);
        self
    }
    
    pub fn crew_capacity(mut self, capacity: u32) -> Self {
        self.crew_capacity = Some(capacity);
        self
    }
    
    pub fn fuel_capacity(mut self, capacity: f32) -> Self {
        if capacity < 1.0 || capacity > 1000000.0 {
            panic!("Fuel capacity must be between 1.0 and 1000000.0");
        }
        self.fuel_capacity = Some(capacity);
        self
    }
}

impl Builder<SpaceShip> for SpaceShipBuilder {
    fn build(self) -> Result<SpaceShip, BuilderError> {
        let name = self.name.ok_or(BuilderError::MissingField("name"))?;
        let mass = self.mass.ok_or(BuilderError::MissingField("mass"))?;
        let engine_power = self.engine_power.ok_or(BuilderError::MissingField("engine_power"))?;
        let crew_capacity = self.crew_capacity.ok_or(BuilderError::MissingField("crew_capacity"))?;
        let fuel_capacity = self.fuel_capacity.ok_or(BuilderError::MissingField("fuel_capacity"))?;
        
        // Additional validation
        if mass <= 0.0 {
            return Err(BuilderError::ValidationFailed("Mass must be positive"));
        }
        
        if engine_power < 0.0 {
            return Err(BuilderError::ValidationFailed("Engine power cannot be negative"));
        }
        
        Ok(SpaceShip {
            name,
            mass,
            engine_power,
            crew_capacity,
            fuel_capacity,
        })
    }
}

// ================================
// Exercise 3: Function-like Macro for Entity Creation
// ================================

pub type EntityId = u64;

pub struct Entity {
    pub id: EntityId,
    pub components: HashMap<u64, Box<dyn SimulationComponent>>,
}

pub struct EntityManager {
    entities: HashMap<EntityId, Entity>,
    next_id: EntityId,
}

impl EntityManager {
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
            next_id: 1,
        }
    }
    
    pub fn create_entity(&mut self) -> EntityId {
        let id = self.next_id;
        self.next_id += 1;
        
        let entity = Entity {
            id,
            components: HashMap::new(),
        };
        
        self.entities.insert(id, entity);
        id
    }
    
    pub fn add_component<T: SimulationComponent + 'static>(&mut self, entity_id: EntityId, component: T) {
        if let Some(entity) = self.entities.get_mut(&entity_id) {
            let component_id = component.component_id();
            entity.components.insert(component_id, Box::new(component));
        }
    }
    
    pub fn get_entity(&self, entity_id: EntityId) -> Option<&Entity> {
        self.entities.get(&entity_id)
    }
    
    pub fn get_component<T>(&self, entity_id: EntityId) -> Option<&T>
    where
        T: SimulationComponent + 'static,
    {
        // This would require more complex type handling in practice
        // For now, return None as a placeholder
        None
    }
}

// Simulate create_entity! macro expansion
macro_rules! create_entity {
    ($manager:expr, { $($component:expr),* $(,)? }) => {
        {
            let entity_id = $manager.create_entity();
            $(
                $manager.add_component(entity_id, $component);
            )*
            entity_id
        }
    };
}

// Example usage of the macro
pub fn example_create_entity(manager: &mut EntityManager) -> EntityId {
    create_entity!(manager, {
        Transform {
            position: [0.0, 0.0, 0.0],
            rotation: [0.0, 0.0, 0.0, 1.0],
            scale: [1.0, 1.0, 1.0],
        },
        RigidBody {
            mass: 1000.0,
            velocity: [0.0, 0.0, 0.0],
            angular_velocity: [0.0, 0.0, 0.0],
            is_kinematic: false,
        }
    })
}

// ================================
// Exercise 4: System Registration Macro
// ================================

pub trait System {
    fn name(&self) -> &'static str;
    fn dependencies(&self) -> Vec<&'static str>;
    fn run(&mut self, manager: &mut EntityManager);
}

pub struct SystemScheduler {
    systems: Vec<Box<dyn System>>,
    dependency_graph: HashMap<String, Vec<String>>,
}

impl SystemScheduler {
    pub fn new() -> Self {
        Self {
            systems: Vec::new(),
            dependency_graph: HashMap::new(),
        }
    }
    
    pub fn register_system<S: System + 'static>(&mut self, system: S) {
        let name = system.name().to_string();
        let dependencies: Vec<String> = system.dependencies().iter().map(|s| s.to_string()).collect();
        
        self.dependency_graph.insert(name, dependencies);
        self.systems.push(Box::new(system));
    }
    
    pub fn run_systems(&mut self, manager: &mut EntityManager) {
        // Simple execution order - in practice would use topological sort
        for system in &mut self.systems {
            system.run(manager);
        }
    }
    
    fn topological_sort(&self) -> Vec<String> {
        // Implementation of topological sort for dependency resolution
        let mut sorted = Vec::new();
        let mut visited = std::collections::HashSet::new();
        let mut temp_visited = std::collections::HashSet::new();
        
        for system_name in self.dependency_graph.keys() {
            if !visited.contains(system_name) {
                self.visit_system(system_name, &mut visited, &mut temp_visited, &mut sorted);
            }
        }
        
        sorted.reverse();
        sorted
    }
    
    fn visit_system(
        &self,
        system_name: &str,
        visited: &mut std::collections::HashSet<String>,
        temp_visited: &mut std::collections::HashSet<String>,
        sorted: &mut Vec<String>,
    ) {
        if temp_visited.contains(system_name) {
            panic!("Circular dependency detected involving system: {}", system_name);
        }
        
        if visited.contains(system_name) {
            return;
        }
        
        temp_visited.insert(system_name.to_string());
        
        if let Some(dependencies) = self.dependency_graph.get(system_name) {
            for dep in dependencies {
                self.visit_system(dep, visited, temp_visited, sorted);
            }
        }
        
        temp_visited.remove(system_name);
        visited.insert(system_name.to_string());
        sorted.push(system_name.to_string());
    }
}

// Simulate register_systems! macro
macro_rules! register_systems {
    ($scheduler:expr, { $($system:expr => { dependencies: [$($dep:expr),*], stage: $stage:expr $(,)? }),* $(,)? }) => {
        $(
            $scheduler.register_system($system);
        )*
    };
}

pub struct PhysicsSystem;
pub struct RenderSystem;

impl System for PhysicsSystem {
    fn name(&self) -> &'static str {
        "PhysicsSystem"
    }
    
    fn dependencies(&self) -> Vec<&'static str> {
        vec![]
    }
    
    fn run(&mut self, _manager: &mut EntityManager) {
        println!("Running PhysicsSystem");
        // Update physics for all entities with Transform and RigidBody components
    }
}

impl System for RenderSystem {
    fn name(&self) -> &'static str {
        "RenderSystem"
    }
    
    fn dependencies(&self) -> Vec<&'static str> {
        vec!["PhysicsSystem"]
    }
    
    fn run(&mut self, _manager: &mut EntityManager) {
        println!("Running RenderSystem");
        // Render all entities with Transform and renderable components
    }
}

// ================================
// Exercise 5: Configuration DSL Macro
// ================================

pub struct SimulationConfig {
    pub gravity: [f32; 3],
    pub time_step: f32,
    pub world_bounds: f32,
    pub entity_limit: usize,
}

pub struct FleetConfig {
    pub name: String,
    pub count: usize,
    pub formation: FormationType,
    pub ship_template: SpaceShip,
}

pub enum FormationType {
    Line { spacing: f32 },
    Circle { radius: f32 },
    Grid { width: usize, height: usize, spacing: f32 },
}

// Simulate simulation_config! macro expansion
macro_rules! simulation_config {
    (
        world {
            gravity: [$gx:expr, $gy:expr, $gz:expr],
            time_step: $time_step:expr,
            bounds: $bounds:expr,
            entity_limit: $limit:expr $(,)?
        }
        
        $(
            fleet $fleet_name:expr {
                count: $count:expr,
                formation: $formation:ident($($formation_args:tt)*),
                ship: $ship:expr $(,)?
            }
        )*
    ) => {
        {
            let sim_config = SimulationConfig {
                gravity: [$gx, $gy, $gz],
                time_step: $time_step,
                world_bounds: $bounds,
                entity_limit: $limit,
            };
            
            let mut fleet_configs = Vec::new();
            
            $(
                let formation = simulation_config!(@formation $formation($($formation_args)*));
                fleet_configs.push(FleetConfig {
                    name: $fleet_name.to_string(),
                    count: $count,
                    formation,
                    ship_template: $ship,
                });
            )*
            
            (sim_config, fleet_configs)
        }
    };
    
    (@formation line(spacing: $spacing:expr)) => {
        FormationType::Line { spacing: $spacing }
    };
    
    (@formation circle(radius: $radius:expr)) => {
        FormationType::Circle { radius: $radius }
    };
    
    (@formation grid(width: $width:expr, height: $height:expr, spacing: $spacing:expr)) => {
        FormationType::Grid { width: $width, height: $height, spacing: $spacing }
    };
}

// Example usage
pub fn create_simulation_config() -> (SimulationConfig, Vec<FleetConfig>) {
    simulation_config! {
        world {
            gravity: [0.0, -9.81, 0.0],
            time_step: 0.016,
            bounds: 1000.0,
            entity_limit: 10000,
        }
        
        fleet "patrol_alpha" {
            count: 5,
            formation: line(spacing: 50.0),
            ship: SpaceShip {
                name: "Patrol Ship".to_string(),
                mass: 1000.0,
                engine_power: 50000.0,
                crew_capacity: 3,
                fuel_capacity: 500.0,
            }
        }
        
        fleet "mining_fleet" {
            count: 10,
            formation: grid(width: 2, height: 5, spacing: 100.0),
            ship: SpaceShip {
                name: "Mining Ship".to_string(),
                mass: 2000.0,
                engine_power: 30000.0,
                crew_capacity: 5,
                fuel_capacity: 800.0,
            }
        }
    }
}

// ================================
// Exercise 6: Attribute Macro for Systems
// ================================

// In practice, this would be a proc-macro attribute
// For now, we simulate with a regular macro

pub struct SystemMetadata {
    pub name: &'static str,
    pub stage: &'static str,
    pub dependencies: Vec<&'static str>,
    pub resources: Vec<&'static str>,
}

// Simulate attribute macro by generating wrapper structs
pub struct MovementSystemWrapper {
    metadata: SystemMetadata,
}

impl MovementSystemWrapper {
    pub fn new() -> Self {
        Self {
            metadata: SystemMetadata {
                name: "movement_system",
                stage: "update",
                dependencies: vec!["input"],
                resources: vec!["Time", "World"],
            },
        }
    }
    
    fn movement_system_impl(&mut self) {
        println!("Executing movement system");
        // Update entity positions based on velocities
    }
}

impl System for MovementSystemWrapper {
    fn name(&self) -> &'static str {
        self.metadata.name
    }
    
    fn dependencies(&self) -> Vec<&'static str> {
        self.metadata.dependencies.clone()
    }
    
    fn run(&mut self, _manager: &mut EntityManager) {
        self.movement_system_impl();
    }
}

pub struct CollisionSystemWrapper {
    metadata: SystemMetadata,
}

impl CollisionSystemWrapper {
    pub fn new() -> Self {
        Self {
            metadata: SystemMetadata {
                name: "collision_system",
                stage: "update",
                dependencies: vec!["movement"],
                resources: vec!["World"],
            },
        }
    }
    
    fn collision_system_impl(&mut self) {
        println!("Executing collision system");
        // Detect and resolve collisions
    }
}

impl System for CollisionSystemWrapper {
    fn name(&self) -> &'static str {
        self.metadata.name
    }
    
    fn dependencies(&self) -> Vec<&'static str> {
        self.metadata.dependencies.clone()
    }
    
    fn run(&mut self, _manager: &mut EntityManager) {
        self.collision_system_impl();
    }
}

// ================================
// Exercise 7: Query Macro for ECS
// ================================

pub struct Query<T> {
    results: Vec<T>,
}

impl<T> Query<T> {
    pub fn new(results: Vec<T>) -> Self {
        Self { results }
    }
    
    pub fn iter(&self) -> impl Iterator<Item = &T> {
        self.results.iter()
    }
    
    pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut T> {
        self.results.iter_mut()
    }
}

// Simulate query! macro
macro_rules! query {
    ($manager:expr, (&$comp1:ident, &mut $comp2:ident)) => {
        {
            // In practice, this would iterate through entities and filter by components
            let results: Vec<(&$comp1, &mut $comp2)> = Vec::new();
            Query::new(results)
        }
    };
    
    ($manager:expr, (&$comp1:ident, Option<&$comp2:ident>)) => {
        {
            let results: Vec<(&$comp1, Option<&$comp2>)> = Vec::new();
            Query::new(results)
        }
    };
}

// Manual query implementation for demonstration
pub fn query_transform_rigidbody(manager: &EntityManager) -> Vec<(EntityId, &Transform, &RigidBody)> {
    let mut results = Vec::new();
    
    for (entity_id, entity) in &manager.entities {
        let transform_id = {
            let mut hasher = DefaultHasher::new();
            "Transform".hash(&mut hasher);
            hasher.finish()
        };
        
        let rigidbody_id = {
            let mut hasher = DefaultHasher::new();
            "RigidBody".hash(&mut hasher);
            hasher.finish()
        };
        
        if entity.components.contains_key(&transform_id) && entity.components.contains_key(&rigidbody_id) {
            // In practice, would safely cast component references
            // For now, create placeholder references
            results.push((*entity_id, &Transform {
                position: [0.0; 3],
                rotation: [0.0, 0.0, 0.0, 1.0],
                scale: [1.0; 3],
            }, &RigidBody {
                mass: 1.0,
                velocity: [0.0; 3],
                angular_velocity: [0.0; 3],
                is_kinematic: false,
            }));
        }
    }
    
    results
}

// ================================
// Exercise 8: Serialization Macro
// ================================

pub trait SimulationSerialize {
    fn serialize_binary(&self) -> Vec<u8>;
    fn deserialize_binary(data: &[u8]) -> Result<Self, SerializationError>
    where
        Self: Sized;
    
    fn serialize_json(&self) -> String;
    fn deserialize_json(json: &str) -> Result<Self, SerializationError>
    where
        Self: Sized;
}

#[derive(Debug)]
pub enum SerializationError {
    InvalidFormat,
    MissingField(String),
    VersionMismatch { expected: u32, found: u32 },
}

pub struct SavedGame {
    pub version: u32,
    pub timestamp: u64,
    pub entities: Vec<EntityId>,
    pub world_state: Vec<u8>,
}

impl SimulationSerialize for SavedGame {
    fn serialize_binary(&self) -> Vec<u8> {
        let mut data = Vec::new();
        
        data.extend_from_slice(&self.version.to_le_bytes());
        data.extend_from_slice(&self.timestamp.to_le_bytes());
        
        data.extend_from_slice(&(self.entities.len() as u32).to_le_bytes());
        for &entity_id in &self.entities {
            data.extend_from_slice(&entity_id.to_le_bytes());
        }
        
        data.extend_from_slice(&(self.world_state.len() as u32).to_le_bytes());
        data.extend_from_slice(&self.world_state);
        
        data
    }
    
    fn deserialize_binary(data: &[u8]) -> Result<Self, SerializationError> {
        if data.len() < 16 {
            return Err(SerializationError::InvalidFormat);
        }
        
        let mut offset = 0;
        
        let version = u32::from_le_bytes([
            data[offset], data[offset + 1], data[offset + 2], data[offset + 3]
        ]);
        offset += 4;
        
        let timestamp = u64::from_le_bytes([
            data[offset], data[offset + 1], data[offset + 2], data[offset + 3],
            data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]
        ]);
        offset += 8;
        
        let entity_count = u32::from_le_bytes([
            data[offset], data[offset + 1], data[offset + 2], data[offset + 3]
        ]) as usize;
        offset += 4;
        
        let mut entities = Vec::with_capacity(entity_count);
        for _ in 0..entity_count {
            if offset + 8 > data.len() {
                return Err(SerializationError::InvalidFormat);
            }
            
            let entity_id = u64::from_le_bytes([
                data[offset], data[offset + 1], data[offset + 2], data[offset + 3],
                data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]
            ]);
            entities.push(entity_id);
            offset += 8;
        }
        
        if offset + 4 > data.len() {
            return Err(SerializationError::InvalidFormat);
        }
        
        let world_state_len = u32::from_le_bytes([
            data[offset], data[offset + 1], data[offset + 2], data[offset + 3]
        ]) as usize;
        offset += 4;
        
        if offset + world_state_len > data.len() {
            return Err(SerializationError::InvalidFormat);
        }
        
        let world_state = data[offset..offset + world_state_len].to_vec();
        
        Ok(SavedGame {
            version,
            timestamp,
            entities,
            world_state,
        })
    }
    
    fn serialize_json(&self) -> String {
        format!(
            r#"{{"version":{},"timestamp":{},"entities":[{}],"world_state":[{}]}}"#,
            self.version,
            self.timestamp,
            self.entities.iter().map(|e| e.to_string()).collect::<Vec<_>>().join(","),
            self.world_state.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(",")
        )
    }
    
    fn deserialize_json(json: &str) -> Result<Self, SerializationError> {
        // Simple JSON parsing for demonstration
        // In practice, would use serde or similar
        
        if !json.starts_with('{') || !json.ends_with('}') {
            return Err(SerializationError::InvalidFormat);
        }
        
        // Very basic parsing - in practice use proper JSON library
        Ok(SavedGame {
            version: 1,
            timestamp: 0,
            entities: vec![],
            world_state: vec![],
        })
    }
}

// ================================
// Exercise 9: Validation Macro
// ================================

pub trait Validate {
    fn validate(&self) -> Result<(), ValidationError>;
}

#[derive(Debug)]
pub enum ValidationError {
    OutOfRange { field: String, value: f32, min: f32, max: f32 },
    Required { field: String },
    InvalidFormat { field: String, expected: String },
    Custom { message: String },
}

pub struct ShipConfiguration {
    pub mass: f32,
    pub engine_power: f32,
    pub name: String,
    pub weapons: Vec<WeaponConfig>,
}

pub struct WeaponConfig {
    pub damage: f32,
    pub fire_rate: f32,
    pub weapon_type: String,
}

impl Validate for ShipConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        // Validate mass range
        if self.mass < 1.0 || self.mass > 1000000.0 {
            return Err(ValidationError::OutOfRange {
                field: "mass".to_string(),
                value: self.mass,
                min: 1.0,
                max: 1000000.0,
            });
        }
        
        // Validate engine power range
        if self.engine_power < 0.0 || self.engine_power > 100000.0 {
            return Err(ValidationError::OutOfRange {
                field: "engine_power".to_string(),
                value: self.engine_power,
                min: 0.0,
                max: 100000.0,
            });
        }
        
        // Validate name length
        if self.name.is_empty() {
            return Err(ValidationError::Required {
                field: "name".to_string(),
            });
        }
        
        if self.name.len() > 50 {
            return Err(ValidationError::InvalidFormat {
                field: "name".to_string(),
                expected: "length <= 50 characters".to_string(),
            });
        }
        
        // Validate weapons
        for (i, weapon) in self.weapons.iter().enumerate() {
            weapon.validate().map_err(|e| match e {
                ValidationError::OutOfRange { field, value, min, max } => {
                    ValidationError::OutOfRange {
                        field: format!("weapons[{}].{}", i, field),
                        value,
                        min,
                        max,
                    }
                }
                _ => e,
            })?;
        }
        
        Ok(())
    }
}

impl Validate for WeaponConfig {
    fn validate(&self) -> Result<(), ValidationError> {
        // Validate damage range
        if self.damage < 1.0 || self.damage > 1000.0 {
            return Err(ValidationError::OutOfRange {
                field: "damage".to_string(),
                value: self.damage,
                min: 1.0,
                max: 1000.0,
            });
        }
        
        // Validate fire rate range
        if self.fire_rate < 0.1 || self.fire_rate > 10.0 {
            return Err(ValidationError::OutOfRange {
                field: "fire_rate".to_string(),
                value: self.fire_rate,
                min: 0.1,
                max: 10.0,
            });
        }
        
        // Validate weapon type
        validate_weapon_type(&self.weapon_type)?;
        
        Ok(())
    }
}

fn validate_weapon_type(weapon_type: &str) -> Result<(), ValidationError> {
    let valid_types = ["laser", "missile", "railgun", "plasma"];
    if valid_types.contains(&weapon_type) {
        Ok(())
    } else {
        Err(ValidationError::InvalidFormat {
            field: "weapon_type".to_string(),
            expected: format!("one of: {}", valid_types.join(", ")),
        })
    }
}

// ================================
// Exercise 10: Performance Macro
// ================================

// Simulate SIMD operation macro
macro_rules! simd_operation {
    (add, $positions:expr, $velocities:expr, $dt:expr) => {
        {
            simd_vector_add($positions, $velocities, $dt);
        }
    };
    
    (multiply, $array:expr, $scalar:expr) => {
        {
            simd_scalar_multiply($array, $scalar);
        }
    };
}

pub fn simd_vector_add(positions: &mut [[f32; 3]], velocities: &[[f32; 3]], dt: f32) {
    // In practice, would use actual SIMD instructions
    for (pos, vel) in positions.iter_mut().zip(velocities.iter()) {
        pos[0] += vel[0] * dt;
        pos[1] += vel[1] * dt;
        pos[2] += vel[2] * dt;
    }
}

pub fn simd_scalar_multiply(array: &mut [f32], scalar: f32) {
    // In practice, would use SIMD for vectorized operations
    for value in array.iter_mut() {
        *value *= scalar;
    }
}

// Simulate profiling attribute macro
pub struct ProfileGuard {
    name: &'static str,
    start_time: std::time::Instant,
}

impl ProfileGuard {
    pub fn new(name: &'static str) -> Self {
        println!("Starting profiling: {}", name);
        Self {
            name,
            start_time: std::time::Instant::now(),
        }
    }
}

impl Drop for ProfileGuard {
    fn drop(&mut self) {
        let elapsed = self.start_time.elapsed();
        println!("Profiling {}: {:?}", self.name, elapsed);
    }
}

macro_rules! profile {
    ($name:expr, $body:expr) => {
        {
            let _guard = ProfileGuard::new($name);
            $body
        }
    };
}

pub fn physics_update() {
    profile!("physics_update", {
        // Physics update logic
        std::thread::sleep(std::time::Duration::from_millis(1));
        println!("Physics updated");
    });
}

// Simulate unroll macro
macro_rules! unroll {
    ($count:expr, |$i:ident| $body:expr) => {
        {
            unroll_impl!($count, 0, |$i| $body);
        }
    };
}

macro_rules! unroll_impl {
    (0, $current:expr, |$i:ident| $body:expr) => {};
    (1, $current:expr, |$i:ident| $body:expr) => {
        { let $i = $current; $body }
    };
    (2, $current:expr, |$i:ident| $body:expr) => {
        { let $i = $current; $body }
        { let $i = $current + 1; $body }
    };
    (3, $current:expr, |$i:ident| $body:expr) => {
        { let $i = $current; $body }
        { let $i = $current + 1; $body }
        { let $i = $current + 2; $body }
    };
    (4, $current:expr, |$i:ident| $body:expr) => {
        { let $i = $current; $body }
        { let $i = $current + 1; $body }
        { let $i = $current + 2; $body }
        { let $i = $current + 3; $body }
    };
}

pub fn unroll_example() {
    let mut array = [0; 4];
    unroll!(4, |i| {
        array[i] = i * 2;
    });
    println!("Unrolled array: {:?}", array);
}

// ================================
// Testing Framework
// ================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simulation_component_derive() {
        let transform = Transform {
            position: [1.0, 2.0, 3.0],
            rotation: [0.0, 0.0, 0.0, 1.0],
            scale: [1.0, 1.0, 1.0],
        };
        
        assert_eq!(transform.component_type(), "Transform");
        assert!(transform.component_id() != 0);
        assert!(!transform.serialize_data().is_empty());
        
        let rigidbody = RigidBody {
            mass: 100.0,
            velocity: [1.0, 0.0, 0.0],
            angular_velocity: [0.0, 0.0, 0.0],
            is_kinematic: false,
        };
        
        assert_eq!(rigidbody.component_type(), "RigidBody");
        assert!(rigidbody.component_id() != transform.component_id());
    }

    #[test]
    fn test_builder_pattern() {
        let ship = SpaceShipBuilder::new()
            .name("Enterprise".to_string())
            .mass(1000.0)
            .engine_power(50000.0)
            .crew_capacity(100)
            .fuel_capacity(500.0)
            .build();
        
        assert!(ship.is_ok());
        let ship = ship.unwrap();
        assert_eq!(ship.name, "Enterprise");
        assert_eq!(ship.mass, 1000.0);
        assert_eq!(ship.engine_power, 50000.0);
        assert_eq!(ship.crew_capacity, 100);
        assert_eq!(ship.fuel_capacity, 500.0);
    }

    #[test]
    fn test_builder_validation() {
        let result = SpaceShipBuilder::new()
            .name("Test".to_string())
            .engine_power(50000.0)
            .crew_capacity(100)
            .fuel_capacity(500.0)
            .build(); // Missing mass
        
        assert!(result.is_err());
        match result {
            Err(BuilderError::MissingField(field)) => assert_eq!(field, "mass"),
            _ => panic!("Expected MissingField error"),
        }
    }

    #[test]
    fn test_entity_creation_macro() {
        let mut manager = EntityManager::new();
        let entity_id = example_create_entity(&mut manager);
        
        assert!(entity_id > 0);
        assert!(manager.get_entity(entity_id).is_some());
        
        let entity = manager.get_entity(entity_id).unwrap();
        assert_eq!(entity.components.len(), 2); // Transform + RigidBody
    }

    #[test]
    fn test_configuration_dsl() {
        let (sim_config, fleet_configs) = create_simulation_config();
        
        assert_eq!(sim_config.gravity, [0.0, -9.81, 0.0]);
        assert_eq!(sim_config.time_step, 0.016);
        assert_eq!(sim_config.world_bounds, 1000.0);
        assert_eq!(sim_config.entity_limit, 10000);
        
        assert_eq!(fleet_configs.len(), 2);
        assert_eq!(fleet_configs[0].name, "patrol_alpha");
        assert_eq!(fleet_configs[0].count, 5);
        
        match &fleet_configs[0].formation {
            FormationType::Line { spacing } => assert_eq!(*spacing, 50.0),
            _ => panic!("Expected Line formation"),
        }
        
        assert_eq!(fleet_configs[1].name, "mining_fleet");
        assert_eq!(fleet_configs[1].count, 10);
        
        match &fleet_configs[1].formation {
            FormationType::Grid { width, height, spacing } => {
                assert_eq!(*width, 2);
                assert_eq!(*height, 5);
                assert_eq!(*spacing, 100.0);
            }
            _ => panic!("Expected Grid formation"),
        }
    }

    #[test]
    fn test_serialization() {
        let saved_game = SavedGame {
            version: 1,
            timestamp: 1234567890,
            entities: vec![1, 2, 3],
            world_state: vec![1, 2, 3, 4],
        };
        
        let binary_data = saved_game.serialize_binary();
        let deserialized = SavedGame::deserialize_binary(&binary_data);
        assert!(deserialized.is_ok());
        
        let deserialized = deserialized.unwrap();
        assert_eq!(deserialized.version, 1);
        assert_eq!(deserialized.timestamp, 1234567890);
        assert_eq!(deserialized.entities, vec![1, 2, 3]);
        assert_eq!(deserialized.world_state, vec![1, 2, 3, 4]);
        
        let json_data = saved_game.serialize_json();
        assert!(json_data.contains("\"version\":1"));
        assert!(json_data.contains("\"timestamp\":1234567890"));
    }

    #[test]
    fn test_validation() {
        let valid_config = ShipConfiguration {
            mass: 1000.0,
            engine_power: 50000.0,
            name: "Test Ship".to_string(),
            weapons: vec![
                WeaponConfig {
                    damage: 100.0,
                    fire_rate: 2.0,
                    weapon_type: "laser".to_string(),
                }
            ],
        };
        
        assert!(valid_config.validate().is_ok());
        
        let invalid_config = ShipConfiguration {
            mass: -100.0, // Invalid: negative mass
            engine_power: 50000.0,
            name: "".to_string(), // Invalid: empty name
            weapons: vec![],
        };
        
        let result = invalid_config.validate();
        assert!(result.is_err());
        
        match result {
            Err(ValidationError::OutOfRange { field, .. }) => {
                assert_eq!(field, "mass");
            }
            _ => panic!("Expected OutOfRange error for mass"),
        }
    }

    #[test]
    fn test_system_registration() {
        let mut scheduler = SystemScheduler::new();
        scheduler.register_system(PhysicsSystem);
        scheduler.register_system(RenderSystem);
        
        let sorted_systems = scheduler.topological_sort();
        assert!(sorted_systems.len() >= 2);
        
        // PhysicsSystem should come before RenderSystem due to dependencies
        let physics_pos = sorted_systems.iter().position(|s| s == "PhysicsSystem").unwrap();
        let render_pos = sorted_systems.iter().position(|s| s == "RenderSystem").unwrap();
        assert!(physics_pos < render_pos);
    }

    #[test]
    fn test_simd_operations() {
        let mut positions = [[0.0; 3]; 4];
        let velocities = [[1.0, 2.0, 3.0]; 4];
        let dt = 0.016;
        
        simd_operation!(add, &mut positions, &velocities, dt);
        
        for i in 0..4 {
            assert_eq!(positions[i], [dt, 2.0 * dt, 3.0 * dt]);
        }
        
        let mut array = [1.0, 2.0, 3.0, 4.0];
        simd_operation!(multiply, &mut array, 2.0);
        
        assert_eq!(array, [2.0, 4.0, 6.0, 8.0]);
    }

    #[test]
    fn test_profiling_macro() {
        physics_update();
        // Test passes if no panic occurs and profiling output is generated
    }

    #[test]
    fn test_unroll_macro() {
        unroll_example();
        // Test passes if no panic occurs
    }

    #[test]
    fn test_system_wrappers() {
        let mut movement_system = MovementSystemWrapper::new();
        let mut collision_system = CollisionSystemWrapper::new();
        
        assert_eq!(movement_system.name(), "movement_system");
        assert_eq!(collision_system.name(), "collision_system");
        
        assert_eq!(movement_system.dependencies(), vec!["input"]);
        assert_eq!(collision_system.dependencies(), vec!["movement"]);
        
        let mut manager = EntityManager::new();
        movement_system.run(&mut manager);
        collision_system.run(&mut manager);
    }
}

// ================================
// Integration Example
// ================================

pub fn integration_example() {
    println!("Starting procedural macro integration example...");
    
    // Entity creation with macro
    let mut manager = EntityManager::new();
    let ship_entity = example_create_entity(&mut manager);
    println!("Created entity with ID: {}", ship_entity);
    
    // System registration with macro
    let mut scheduler = SystemScheduler::new();
    
    register_systems!(scheduler, {
        PhysicsSystem => {
            dependencies: [],
            stage: "update",
        },
        RenderSystem => {
            dependencies: ["PhysicsSystem"],
            stage: "render",
        }
    });
    
    println!("Registered systems");
    
    // Configuration with DSL
    let (sim_config, fleet_configs) = create_simulation_config();
    println!("Created simulation config with {} fleets", fleet_configs.len());
    println!("World bounds: {}", sim_config.world_bounds);
    
    // Builder pattern usage
    let ship = SpaceShipBuilder::new()
        .name("Integration Test Ship".to_string())
        .mass(1500.0)
        .engine_power(75000.0)
        .crew_capacity(8)
        .fuel_capacity(600.0)
        .build()
        .expect("Failed to build ship");
    
    println!("Built ship: {}", ship.name);
    
    // Validation example
    let ship_config = ShipConfiguration {
        mass: ship.mass,
        engine_power: ship.engine_power,
        name: ship.name.clone(),
        weapons: vec![
            WeaponConfig {
                damage: 150.0,
                fire_rate: 3.0,
                weapon_type: "plasma".to_string(),
            }
        ],
    };
    
    match ship_config.validate() {
        Ok(()) => println!("Ship configuration is valid"),
        Err(e) => println!("Validation error: {:?}", e),
    }
    
    // Serialization example
    let saved_game = SavedGame {
        version: 1,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs(),
        entities: vec![ship_entity],
        world_state: vec![1, 2, 3, 4, 5],
    };
    
    let serialized = saved_game.serialize_binary();
    println!("Serialized game state: {} bytes", serialized.len());
    
    // Performance macro example
    let mut positions = [[0.0; 3]; 100];
    let velocities = [[1.0, 0.0, 0.0]; 100];
    let dt = 0.016;
    
    profile!("vector_update", {
        simd_operation!(add, &mut positions, &velocities, dt);
    });
    
    println!("Updated {} positions with SIMD operations", positions.len());
    
    // Run systems
    scheduler.run_systems(&mut manager);
    
    // Unroll example
    unroll_example();
    
    println!("Integration example completed successfully!");
}

// ================================
// Macro Development Utilities
// ================================

pub mod macro_utils {
    use std::hash::{Hash, Hasher};
    use std::collections::hash_map::DefaultHasher;
    
    pub fn generate_hash(input: &str) -> u64 {
        let mut hasher = DefaultHasher::new();
        input.hash(&mut hasher);
        hasher.finish()
    }
    
    pub fn validate_identifier(name: &str) -> bool {
        if name.is_empty() {
            return false;
        }
        
        let first_char = name.chars().next().unwrap();
        if !first_char.is_alphabetic() && first_char != '_' {
            return false;
        }
        
        name.chars().all(|c| c.is_alphanumeric() || c == '_')
    }
    
    pub fn format_error_message(context: &str, error: &str) -> String {
        format!("Error in {}: {}", context, error)
    }
    
    pub fn to_snake_case(input: &str) -> String {
        let mut result = String::new();
        let mut prev_was_lowercase = false;
        
        for c in input.chars() {
            if c.is_uppercase() && prev_was_lowercase {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
            prev_was_lowercase = c.is_lowercase();
        }
        
        result
    }
    
    pub fn to_pascal_case(input: &str) -> String {
        input
            .split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase(),
                }
            })
            .collect()
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
        
        #[test]
        fn test_generate_hash() {
            let hash1 = generate_hash("Transform");
            let hash2 = generate_hash("RigidBody");
            let hash3 = generate_hash("Transform");
            
            assert_ne!(hash1, hash2);
            assert_eq!(hash1, hash3);
        }
        
        #[test]
        fn test_validate_identifier() {
            assert!(validate_identifier("valid_name"));
            assert!(validate_identifier("_private"));
            assert!(validate_identifier("Component123"));
            
            assert!(!validate_identifier("123invalid"));
            assert!(!validate_identifier("invalid-name"));
            assert!(!validate_identifier(""));
        }
        
        #[test]
        fn test_case_conversion() {
            assert_eq!(to_snake_case("CamelCase"), "camel_case");
            assert_eq!(to_snake_case("XMLHttpRequest"), "x_m_l_http_request");
            
            assert_eq!(to_pascal_case("snake_case"), "SnakeCase");
            assert_eq!(to_pascal_case("multi_word_name"), "MultiWordName");
        }
    }
}